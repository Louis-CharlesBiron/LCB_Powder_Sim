#!/usr/bin/env node
import{spawn}from"child_process";import{createRequire}from"module";import{dirname,join}from"path";import{createInterface}from"readline";const PACKAGE_JSON=createRequire(import.meta.url)("../package.json"),PACKAGE_NAME=PACKAGE_JSON.name,VERSION=PACKAGE_JSON.version,HELP_LIST_TEXT=`\nType 'npx ${PACKAGE_NAME} list' for a list of all commands.`,COMMANDS={template:"createProjectTemplate.min.js","browser-template":"createBrowserProjectTemplate.min.js",documentation:"openDocumentation.min.js",help:"help",list:"list",version:"version"},PARAMS={SKIP_AUTOCOMPLETION_CONFIRM:["-y","-f"],YES:["y","yes","ye","ok","for sure"]},ALIASES={doc:"documentation",v:"version",ls:"list",t:"template",bt:"browser-template"},COMMANDS_DESC={template:"Creates a simple ESM project template. Takes an optional folder path in parameter.","browser-template":"Creates a simple UMD project template. Takes an optional folder path in parameter.",documentation:"Opens the documentation",help:"Shows commands syntax",list:"Shows all available commands and aliases",version:"Returns the installed version of the librairy"},rawCommand=process.argv[2]?.toLowerCase().trim(),command=function(commandInput,params){ALIASES[commandInput]&&(commandInput=ALIASES[commandInput]);const isDirectFind=Boolean(COMMANDS[commandInput]),[cmd,cmdValue]=Object.entries(COMMANDS).find(([commandsKey])=>commandsKey.toLowerCase().includes(commandInput))||[];return cmd&&commandInput!==PACKAGE_NAME?{wasAutoCompleted:!isDirectFind&&!params.some(param=>PARAMS.SKIP_AUTOCOMPLETION_CONFIRM.includes(param)),cmdName:cmd,cmd:cmd===cmdValue?cmd:join(dirname(process.argv[1]),cmdValue),params:params.filter(x=>!PARAMS.SKIP_AUTOCOMPLETION_CONFIRM.includes(x))}:null}(rawCommand,process.argv.slice(3));if(command)if(command.wasAutoCompleted){const cli=createInterface({input:process.stdin,output:process.stdout});cli.question(`The command was autocompleted to '${command.cmdName}', continue [Y/N]? `,value=>{const v=value?.toLowerCase()?.trim();v&&!PARAMS.YES.includes(v)||executeCmd(command),cli.close()}),process.stdin.on("keypress",(_,key)=>{"escape"===key.name.toLowerCase()&&cli.close()})}else executeCmd(command);else null==rawCommand?console.log(`\nNo command specified...${HELP_LIST_TEXT}\n`):console.log(`\n'${rawCommand}' is not part of any ${PACKAGE_NAME} command...${HELP_LIST_TEXT}\n`);function executeCmd(command){const{cmd:cmd,params:params}=command;cmd===COMMANDS.list?console.log(`\nList of available npx commands for ${PACKAGE_NAME}:\n\nCOMMANDS:\n${Object.keys(COMMANDS).map(x=>{const command=x.toLowerCase();return`  - ${command}:  ${COMMANDS_DESC[command]}`}).join("\n")}\n\nALIASES:\n${Object.entries(ALIASES).map(([name,cmd])=>`  - ${name.toLowerCase()}:  Alias for '${cmd}'`).join("\n")}\n`):cmd===COMMANDS.help?console.log(`The syntax for ${PACKAGE_NAME} commands is:\n\nnpx ${PACKAGE_NAME} 'command' [-y | -f]?\n${HELP_LIST_TEXT}\n`):cmd===COMMANDS.version?console.log(`v${VERSION}\n`):spawn("node",[cmd,...params],{stdio:"inherit"})}